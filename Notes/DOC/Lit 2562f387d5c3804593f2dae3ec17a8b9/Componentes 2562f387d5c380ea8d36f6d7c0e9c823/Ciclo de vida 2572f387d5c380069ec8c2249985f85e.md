# Ciclo de vida

Los componentes **Lit** usan los **mÃ©todos estÃ¡ndar** del ciclo de vida de los *custom elements*. AdemÃ¡s, Lit aÃ±ade un **ciclo de actualizaciÃ³n reactivo** que vuelve a renderizar el DOM cuando cambian las **propiedades reactivas**.

---

## ğŸ§­ Ciclo de vida estÃ¡ndar de *custom elements*

- Los componentes Lit **heredan** los callbacks estÃ¡ndar. GuÃ­a: [*Using the lifecycle callbacks* (MDN)](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements#using_the_lifecycle_callbacks).
- Si sobreescribes un callback, **llama siempre a** `super.<callback>()` (p. ej. `super.connectedCallback()`) para mantener el comportamiento de Lit.

---

## ğŸ› ï¸ `constructor()`

**CuÃ¡ndo se llama:** al crear el elemento o al **actualizarse** (*upgrade*) cuando su definiciÃ³n se carga despuÃ©s de estar ya en el DOM.

**Lit hace:**

- Pide una actualizaciÃ³n asÃ­ncrona con `requestUpdate()` â†’ el componente se actualiza inmediatamente tras el *upgrade*.
- Conserva propiedades ya establecidas en el elemento (valores pre-*upgrade* > valores por defecto del componente).

**Ãšsalo para:**

- Inicializaciones **una sola vez** previas al primer render; por ejemplo, valores por defecto si no usas decoradores.

```tsx
constructor() {
  super();
  this.foo = 'foo';
  this.bar = 'bar';
}

```

---

## ğŸ”Œ `connectedCallback()`

**CuÃ¡ndo se llama:** al insertarse en el DOM.

**Lit hace:**

- Inicia el **primer ciclo de actualizaciÃ³n** y asegura la creaciÃ³n de `renderRoot` (normalmente `shadowRoot`).
- Tras haberse conectado **al menos una vez**, las actualizaciones del componente continÃºan **aunque se desconecte** temporalmente.

**Ãšsalo para:**

- Tareas que solo deben ocurrir estando **conectado** (escuchadores en `window`, `document`, etc.).
- Todo lo que aÃ±adas aquÃ­ a **nodos externos** quÃ­talo en `disconnectedCallback()`.

```tsx
connectedCallback() {
  super.connectedCallback();
  window.addEventListener('keydown', this._handleKeydown);
}

```

---

## ğŸ”ŒğŸš« `disconnectedCallback()`

**CuÃ¡ndo se llama:** al quitarse del DOM.

**Lit hace:**

- **Pausa** el ciclo reactivo (se reanuda al reconectar).

**Ãšsalo para:**

- Soltar referencias externas: quitar listeners en `window/document`, parar *timers*, *observers*, etc.
- Ojo: si el elemento se **reconecta** (mover en el DOM, cachÃ©), reanuda lo necesario en `connectedCallback()`.

```tsx
disconnectedCallback() {
  super.disconnectedCallback();
  window.removeEventListener('keydown', this._handleKeydown);
}

```

> ğŸ“ No hace falta quitar listeners internos del propio DOM/plantilla del componente; no impiden el garbage collection.
> 

---

## ğŸ·ï¸ `attributeChangedCallback()`

**CuÃ¡ndo se llama:** cuando cambia un atributo de `observedAttributes`.

**Lit hace:**

- Sincroniza **atributos â†’ propiedades reactivas** automÃ¡ticamente.
- Define `observedAttributes` segÃºn la lista de propiedades reactivas del componente.

**Ãšsalo para:**

- **Casi nunca.** Lit ya gestiona esta sincronizaciÃ³n.

---

## ğŸšš `adoptedCallback()`

**CuÃ¡ndo se llama:** cuando el elemento se mueve a **otro documento** (p. ej., *iframes*).

**Lit hace:**

- No define comportamiento por defecto. *(No estÃ¡ polyfilled).*

**Ãšsalo para:**

- Casos **avanzados** donde el comportamiento cambie al cambiar de documento.

---

## ğŸ§© PatrÃ³n recomendado (plantilla)

```tsx
import {LitElement, html} from 'lit';
import {customElement, property} from 'lit/decorators.js';

@customElement('my-el')
export class MyEl extends LitElement {
  @property({type: String, reflect: true}) theme = 'light';
  @property({type: Number}) count = 0;

  constructor() {
    super();
    // Init Ãºnico antes del primer render
    this.count = 0;
  }

  connectedCallback() {
    super.connectedCallback();
    // Listeners EXTERNOS
    window.addEventListener('keydown', this._onKey);
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    // Limpiar EXTERNOS
    window.removeEventListener('keydown', this._onKey);
  }

  private _onKey = (e: KeyboardEvent) => {
    if (e.key === 'ArrowUp') this.count++;
  };

  protected render() {
    return html`
      <button @click=${() => this.count++}>${this.theme} Â· ${this.count}
      </button>
    `;
  }
}

```

---

## âœ… Reglas de oro (rÃ¡pidas)

- Llama **siempre** a `super.*Callback()`.
- **Externos** (window/document): add en `connected`, remove en `disconnected`.
- Usa **propiedades reactivas**; Lit re-renderiza cuando **cambian**.
- Si necesitas reflejar estado en HTML/atributos â†’ `@property({ reflect: true })`.

# âš¡ Ciclo de actualizaciÃ³n reactiva (Lit)

Los componentes **Lit** usan los mÃ©todos estÃ¡ndar del ciclo de vida de los *custom elements*. **AdemÃ¡s**, Lit implementa un **ciclo de actualizaciÃ³n reactiva** que renderiza cambios en el **DOM** cuando cambian las **propiedades reactivas**.

> ğŸ–¼ï¸ Diagrama del flujo (arriba): constructor() / @property() / attributeChangedCallback() â†’ Property Setter â†’ hasChanged() â†’ requestUpdate().
> 

![image.png](Ciclo%20de%20vida%202572f387d5c380069ec8c2249985f85e/image.png)

![image.png](Ciclo%20de%20vida%202572f387d5c380069ec8c2249985f85e/image%201.png)

![image.png](Ciclo%20de%20vida%202572f387d5c380069ec8c2249985f85e/image%202.png)

---

## ğŸ¯ Â¿CuÃ¡ndo se activa?

- ğŸ” Cuando cambia **una propiedad reactiva**.
- ğŸ§© Cuando llamas explÃ­citamente a **`requestUpdate()`**.

> Lit actualiza en asÃ­ncrono y agrupa cambios: si pides una actualizaciÃ³n y cambian mÃ¡s propiedades antes de que empiece el update, todas se incluyen en la misma actualizaciÃ³n.
> 

---

## â±ï¸ TemporizaciÃ³n (microtareas)

- Las actualizaciones ocurren con **timing de microtarea** (*microtask*): **antes** de que el navegador pinte el siguiente frame.
- Referencia: artÃ­culo de [**Jake Archibald** sobre *microtasks*](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/) (timings del navegador).

---

## ğŸ§­ Resumen de alto nivel (paso a paso)

1. ğŸ—“ï¸ **Se programa** una actualizaciÃ³n cuando cambian propiedades o se llama a `requestUpdate()`.
2. ğŸ–¼ï¸ **Se ejecuta** la actualizaciÃ³n **antes** del prÃ³ximo repintado del navegador.
3. ğŸ·ï¸ **Se reflejan** los atributos (*reflecting attributes*).
4. ğŸ§± Se llama a **`render()`** del componente para actualizar su **DOM interno**.
5. âœ… La actualizaciÃ³n **finaliza** y la promesa **`updateComplete`** queda **resuelta**.

---

## ğŸ§ª En mÃ¡s detalle (estructura)

- **Pre-Update**
- **Update**
- **Post-Update**

*(Estos bloques corresponden al flujo que Lit ejecuta alrededor de tu `render()` y del reflejo de atributos).*

---

## ğŸ“Œ Notas clave (para no pisarte el render)

- ğŸ§  **Batching** real: mÃºltiples cambios **â†’** un solo render.
- â™»ï¸ `requestUpdate()` **no** fuerza render inmediato; solo **agenda** el ciclo.
- ğŸ·ï¸ Si usas `@property({ reflect: true })`, el atributo del host se **sincroniza** en el paso de reflejo.