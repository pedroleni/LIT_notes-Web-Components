# Ciclo de vida

Los componentes **Lit** usan los **métodos estándar** del ciclo de vida de los *custom elements*. Además, Lit añade un **ciclo de actualización reactivo** que vuelve a renderizar el DOM cuando cambian las **propiedades reactivas**.

---

## 🧭 Ciclo de vida estándar de *custom elements*

- Los componentes Lit **heredan** los callbacks estándar. Guía: [*Using the lifecycle callbacks* (MDN)](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements#using_the_lifecycle_callbacks).
- Si sobreescribes un callback, **llama siempre a** `super.<callback>()` (p. ej. `super.connectedCallback()`) para mantener el comportamiento de Lit.

---

## 🛠️ `constructor()`

**Cuándo se llama:** al crear el elemento o al **actualizarse** (*upgrade*) cuando su definición se carga después de estar ya en el DOM.

**Lit hace:**

- Pide una actualización asíncrona con `requestUpdate()` → el componente se actualiza inmediatamente tras el *upgrade*.
- Conserva propiedades ya establecidas en el elemento (valores pre-*upgrade* > valores por defecto del componente).

**Úsalo para:**

- Inicializaciones **una sola vez** previas al primer render; por ejemplo, valores por defecto si no usas decoradores.

```tsx
constructor() {
  super();
  this.foo = 'foo';
  this.bar = 'bar';
}

```

---

## 🔌 `connectedCallback()`

**Cuándo se llama:** al insertarse en el DOM.

**Lit hace:**

- Inicia el **primer ciclo de actualización** y asegura la creación de `renderRoot` (normalmente `shadowRoot`).
- Tras haberse conectado **al menos una vez**, las actualizaciones del componente continúan **aunque se desconecte** temporalmente.

**Úsalo para:**

- Tareas que solo deben ocurrir estando **conectado** (escuchadores en `window`, `document`, etc.).
- Todo lo que añadas aquí a **nodos externos** quítalo en `disconnectedCallback()`.

```tsx
connectedCallback() {
  super.connectedCallback();
  window.addEventListener('keydown', this._handleKeydown);
}

```

---

## 🔌🚫 `disconnectedCallback()`

**Cuándo se llama:** al quitarse del DOM.

**Lit hace:**

- **Pausa** el ciclo reactivo (se reanuda al reconectar).

**Úsalo para:**

- Soltar referencias externas: quitar listeners en `window/document`, parar *timers*, *observers*, etc.
- Ojo: si el elemento se **reconecta** (mover en el DOM, caché), reanuda lo necesario en `connectedCallback()`.

```tsx
disconnectedCallback() {
  super.disconnectedCallback();
  window.removeEventListener('keydown', this._handleKeydown);
}

```

> 📝 No hace falta quitar listeners internos del propio DOM/plantilla del componente; no impiden el garbage collection.
> 

---

## 🏷️ `attributeChangedCallback()`

**Cuándo se llama:** cuando cambia un atributo de `observedAttributes`.

**Lit hace:**

- Sincroniza **atributos → propiedades reactivas** automáticamente.
- Define `observedAttributes` según la lista de propiedades reactivas del componente.

**Úsalo para:**

- **Casi nunca.** Lit ya gestiona esta sincronización.

---

## 🚚 `adoptedCallback()`

**Cuándo se llama:** cuando el elemento se mueve a **otro documento** (p. ej., *iframes*).

**Lit hace:**

- No define comportamiento por defecto. *(No está polyfilled).*

**Úsalo para:**

- Casos **avanzados** donde el comportamiento cambie al cambiar de documento.

---

## 🧩 Patrón recomendado (plantilla)

```tsx
import {LitElement, html} from 'lit';
import {customElement, property} from 'lit/decorators.js';

@customElement('my-el')
export class MyEl extends LitElement {
  @property({type: String, reflect: true}) theme = 'light';
  @property({type: Number}) count = 0;

  constructor() {
    super();
    // Init único antes del primer render
    this.count = 0;
  }

  connectedCallback() {
    super.connectedCallback();
    // Listeners EXTERNOS
    window.addEventListener('keydown', this._onKey);
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    // Limpiar EXTERNOS
    window.removeEventListener('keydown', this._onKey);
  }

  private _onKey = (e: KeyboardEvent) => {
    if (e.key === 'ArrowUp') this.count++;
  };

  protected render() {
    return html`
      <button @click=${() => this.count++}>${this.theme} · ${this.count}
      </button>
    `;
  }
}

```

---

## ✅ Reglas de oro (rápidas)

- Llama **siempre** a `super.*Callback()`.
- **Externos** (window/document): add en `connected`, remove en `disconnected`.
- Usa **propiedades reactivas**; Lit re-renderiza cuando **cambian**.
- Si necesitas reflejar estado en HTML/atributos → `@property({ reflect: true })`.

# ⚡ Ciclo de actualización reactiva (Lit)

Los componentes **Lit** usan los métodos estándar del ciclo de vida de los *custom elements*. **Además**, Lit implementa un **ciclo de actualización reactiva** que renderiza cambios en el **DOM** cuando cambian las **propiedades reactivas**.

> 🖼️ Diagrama del flujo (arriba): constructor() / @property() / attributeChangedCallback() → Property Setter → hasChanged() → requestUpdate().
> 

![image.png](Ciclo%20de%20vida%202572f387d5c380069ec8c2249985f85e/image.png)

![image.png](Ciclo%20de%20vida%202572f387d5c380069ec8c2249985f85e/image%201.png)

![image.png](Ciclo%20de%20vida%202572f387d5c380069ec8c2249985f85e/image%202.png)

---

## 🎯 ¿Cuándo se activa?

- 🔁 Cuando cambia **una propiedad reactiva**.
- 🧩 Cuando llamas explícitamente a **`requestUpdate()`**.

> Lit actualiza en asíncrono y agrupa cambios: si pides una actualización y cambian más propiedades antes de que empiece el update, todas se incluyen en la misma actualización.
> 

---

## ⏱️ Temporización (microtareas)

- Las actualizaciones ocurren con **timing de microtarea** (*microtask*): **antes** de que el navegador pinte el siguiente frame.
- Referencia: artículo de [**Jake Archibald** sobre *microtasks*](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/) (timings del navegador).

---

## 🧭 Resumen de alto nivel (paso a paso)

1. 🗓️ **Se programa** una actualización cuando cambian propiedades o se llama a `requestUpdate()`.
2. 🖼️ **Se ejecuta** la actualización **antes** del próximo repintado del navegador.
3. 🏷️ **Se reflejan** los atributos (*reflecting attributes*).
4. 🧱 Se llama a **`render()`** del componente para actualizar su **DOM interno**.
5. ✅ La actualización **finaliza** y la promesa **`updateComplete`** queda **resuelta**.

---

## 🧪 En más detalle (estructura)

- **Pre-Update**
- **Update**
- **Post-Update**

*(Estos bloques corresponden al flujo que Lit ejecuta alrededor de tu `render()` y del reflejo de atributos).*

---

## 📌 Notas clave (para no pisarte el render)

- 🧠 **Batching** real: múltiples cambios **→** un solo render.
- ♻️ `requestUpdate()` **no** fuerza render inmediato; solo **agenda** el ciclo.
- 🏷️ Si usas `@property({ reflect: true })`, el atributo del host se **sincroniza** en el paso de reflejo.