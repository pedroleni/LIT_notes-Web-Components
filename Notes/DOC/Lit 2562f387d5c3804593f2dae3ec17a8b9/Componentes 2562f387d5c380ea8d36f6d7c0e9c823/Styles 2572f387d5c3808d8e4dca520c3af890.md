# Styles

Los **templates de tus componentes** se renderizan dentro de su **shadow root**.

Los estilos que defines dentro del componente quedan **aislados autom√°ticamente** gracias al Shadow DOM y **solo afectan a los elementos internos** de ese componente.

üëâ Esto significa que:

- No tienes que preocuparte por romper estilos fuera de tu componente.
- Evitas escribir nombres de clases largu√≠simos y molestos para no ‚Äúchocar‚Äù con otros estilos.
- Los selectores que uses en tu componente se aplican **solo dentro de su shadow root**.

---

## üìå A√±adiendo estilos en Lit

Se definen en la propiedad **`static styles`** de la clase, usando el *tagged template literal* `css`.

Ejemplo sencillo:

```tsx
//TS 

import {LitElement, html, css} from 'lit';
import {customElement} from 'lit/decorators.js';

@customElement('my-element')
export class MyElement extends LitElement {
  static styles = css`
    p {
      color: green;
    }
  `;
  protected render() {
    return html`<p>¬°Soy verde!</p>`;
  }
}

```

```tsx
//JS

import {LitElement, html, css} from 'lit';

export class MyElement extends LitElement {
  static styles = css`
    p {
      color: green;
    }
  `;
  render() {
    return html`<p>I am green!</p>`;
  }
}
customElements.define('my-element', MyElement);

```

üëâ Estos estilos se aplican **solo dentro del shadow root** del componente.

---

## üìö Formas de definir estilos

1. **Literal √∫nico**

```tsx
static styles = css`p { color: red; }`;

```

1. **Array de literales** (√∫til para herencia o estilos compartidos):

```tsx
static styles = [ css`p { color: red; }`, css`div { margin: 10px; }` ];

```

‚ö° En el 99% de los casos, `static styles` es la mejor forma de a√±adir estilos.

---

## üåÄ Expresiones en estilos

Los estilos est√°ticos se aplican a **todas las instancias** del componente.

Si necesitas personalizaci√≥n por instancia, utiliza **propiedades CSS personalizadas** (`--mi-color`).

Ejemplo seguro con `css`:

```tsx
const mainColor = css`red`;

static styles = css`
  div { color: ${mainColor}; }
`;

```

Ejemplo usando `unsafeCSS` (‚ö†Ô∏è solo con valores **confiables**):

```tsx
import {unsafeCSS} from 'lit';

const mainColor = 'red';

static styles = css`
  div { color: ${unsafeCSS(mainColor)}; }
`;

```

‚ö†Ô∏è **Advertencia:** inyectar CSS sin sanitizar es un riesgo de seguridad.

---

## üß¨ Herencia de estilos

Puedes heredar estilos de una **superclase** y a√±adir nuevos:

- JS
    
    ```jsx
    //my-element.js
    import {css} from 'lit';
    import {customElement} from 'lit/decorators.js';
    import {SuperElement} from './super-element.js';
    
    @customElement('my-element')
    export class MyElement extends SuperElement {
      static styles = [
        SuperElement.styles,
        css`div { color: red; }`
      ];
    }
    
    ```
    
    ```jsx
    //super-element.js
    import {LitElement, html, css} from 'lit';
    
    export class SuperElement extends LitElement {
      static styles = css`
        div {
          border: 1px solid gray;
          padding: 8px;
        }
      `;
      render() {
        return html`
          <div>Content</div>
        `;
      }
    }
    customElements.define('super-element', SuperElement);
    ```
    
    ```html
    <script type="module" src="./my-element.js"></script>
    
    <my-element></my-element>
    ```
    
    ![image.png](Styles%202572f387d5c3808d8e4dca520c3af890/image.png)
    

```tsx
// my-element.ts
import {css} from 'lit';
import {customElement} from 'lit/decorators.js';
import {SuperElement} from './super-element.js';

@customElement('my-element')
export class MyElement extends SuperElement {
  static styles = [
    SuperElement.styles,
    css`div {
      color: red;
    }`
  ];
}

```

```tsx
// super-element.ts

import {LitElement, html, css, CSSResultGroup} from 'lit';
import {customElement} from 'lit/decorators.js';

@customElement('super-element')
export class SuperElement extends LitElement {
  static styles = css`
    div {
      border: 1px solid gray;
      padding: 8px;
    }
  ` as CSSResultGroup;
  protected render() {
    return html`
      <div>Content</div>
    `;
  }
}

```

```html
// index.html

<script type="module" src="./my-element.js"></script>

<my-element></my-element>

```

![image.png](Styles%202572f387d5c3808d8e4dca520c3af890/image%201.png)

üëâ En TypeScript, mejor **referenciar la clase directamente** (`SuperElement.styles`) en vez de usar `super.styles`.

Si tu componente est√° pensado para ser extendido, tipa as√≠:

```tsx
import {CSSResultGroup, css} from 'lit';

static styles: CSSResultGroup = css`...`;

```

---

## ‚ôªÔ∏è Compartir estilos entre componentes

Puedes definir estilos comunes en un m√≥dulo y reutilizarlos:

```tsx
// button-styles.ts
import {css} from 'lit';

export const buttonStyles = css`
  .blue-button {
    color: white;
    background-color: blue;
  }
  .blue-button:disabled {
    background-color: grey;
  }
`;

```

Y luego usarlos en un componente:

```tsx
import {LitElement, css} from 'lit';
import {buttonStyles} from './button-styles.js';

class MyElement extends LitElement {
  static styles = [
    buttonStyles,
    css`
      :host {
        display: block;
        border: 1px solid black;
      }
    `
  ];
}

```

---

## üî° Usar Unicode en estilos

En CSS, los escapes Unicode usan `\2022` (por ejemplo, un punto medio).

Pero dentro de un literal `css` esto puede dar error.

Soluciones:

- Doble barra: `\\2022`
- Secuencia JS: `\u2022`

Ejemplo:

```tsx
static styles = css`
  div::before {
    content: '\u2022'; /* ‚Ä¢ */
  }
`;

```

---

# üåë Estilos con Shadow DOM en Lit

El **Shadow DOM** encapsula el estilo y la estructura de un componente. Esto significa que los estilos que defines en tu componente pueden aplicarse a:

1. **El shadow tree** ‚Üí el contenido renderizado del template.
2. **El propio componente (host)** ‚Üí el elemento que contiene el shadow root.
3. **Los hijos del componente** ‚Üí elementos que se renderizan dentro de `<slot>`.

---

## üé® 1. Estilando el shadow tree

Los templates en Lit se renderizan en un **shadow tree**.

üëâ Los estilos definidos ah√≠ **no afectan al documento principal ni a otros shadow trees**.

Del mismo modo, los estilos globales del documento **no afectan** a lo que est√° dentro de un shadow tree (excepto propiedades heredadas, como `color` o `font-family`).

Ejemplo: puedes usar selectores muy simples sin miedo a colisiones externas:

```css
input {
  border: 1px solid black;
}

* {
  font-family: sans-serif;
}

#my-element {
  padding: 10px;
}

```

---

## üè† 2. Estilando el componente (host)

El **host element** es el elemento que ‚Äúposee‚Äù el shadow root.

Para darle estilos usamos el pseudo-selector `:host`.

Ejemplo:

```tsx
import {LitElement, html, css} from 'lit';
import {customElement} from 'lit/decorators.js';

@customElement('my-element')
export class MyElement extends LitElement {
  static styles = css`
    :host {
      display: block;
      background-color: lightgray;
      padding: 8px;
    }
    :host(.blue) {
      background-color: aliceblue;
      color: darkgreen;
    }
  `;
  protected render() {
    return html`Hello World`;
  }
}

```

```tsx
import {LitElement, html, css} from 'lit';

export class MyElement extends LitElement {
  static styles = css`
    :host {
      display: block;
      background-color: lightgray;
      padding: 8px;
    }
    :host(.blue) {
      background-color: aliceblue;
      color: darkgreen;
    }
  `;
  render() {
    return html`Hello World`;
  }
}
customElements.define('my-element', MyElement);

```

![image.png](Styles%202572f387d5c3808d8e4dca520c3af890/image%202.png)

üëâ Notas importantes:

- `:host` aplica siempre.
- `:host(.blue)` solo aplica si el componente tiene la clase `.blue`.
- El host **tambi√©n puede recibir estilos externos**:

```css
my-element {
  display: inline-block; /* Sobrescribe los estilos por defecto */
}

```

---

## üë∂ 3. Estilando los hijos del componente (slotted)

Un componente puede aceptar hijos, igual que un `<ul>` acepta `<li>`.

Para ello, el template incluye `<slot>`:

```html
<slot></slot>
<slot name="hi"></slot>

```

Para estilar los elementos que entran por esos *slots* se usa `::slotted()`:

```tsx
static styles = css`
  ::slotted(*) { font-family: Roboto; }
  ::slotted(p) { color: blue; }
  div ::slotted(*) { color: red; }
`;

```

Ejemplo de uso:

```html
<my-element>
  <div>‚úî Estilable con ::slotted()</div>
</my-element>

<my-element>
  <div><p>‚ùå No estilable con ::slotted()</p></div>
</my-element>

```

üëâ **Importante**: `::slotted()` solo afecta a los hijos directos pasados al slot, no a sus descendientes.

Adem√°s, **los estilos externos tambi√©n pueden sobrescribir a ::slotted()**:

```css
my-element > div {
  color: black; /* Sobrescribe estilos internos */
}

```

---

## ‚ö†Ô∏è Limitaciones con ShadyCSS

Si usas el polyfill **ShadyCSS** (para navegadores sin soporte completo de Shadow DOM), hay algunas restricciones en el uso de `::slotted()`.

Consulta la secci√≥n oficial de [Limitaciones de ShadyCSS](https://github.com/webcomponents/polyfills/tree/master/packages/shadycss#limitations)

---

# üñåÔ∏è Definiendo estilos dentro del template en Lit

üëâ La forma **recomendada** de a√±adir estilos es usar `static styles`, porque da el mejor rendimiento.

Pero en algunos casos puedes querer definir estilos directamente en el **template**.

Lit permite dos formas de hacerlo:

1. Usar un elemento `<style>` dentro del `render()`.
2. Usar una hoja de estilos externa (‚ö†Ô∏è no recomendado).

Cada enfoque tiene ventajas y limitaciones.

---

## 1. Estilos en un `<style>` dentro del template

Los estilos en `static styles` se eval√∫an **una vez por clase**.

Si necesitas estilos **personalizados por instancia**, normalmente se recomienda usar **propiedades CSS** (`--mi-color`).

üëâ Como alternativa, tambi√©n puedes incluir `<style>` dentro del template.

Estos se actualizan **por instancia**:

```tsx
render() {
  return html`
    <style>
      /* Estilos que se actualizan por instancia */
      div { color: green; }
    </style>
    <div>Contenido del template</div>
  `;
}

```

‚ö†Ô∏è **Limitaci√≥n**: en navegadores que dependan del polyfill **ShadyCSS**, los estilos por instancia **no son compatibles**.

---

## 2. Expresiones dentro de `<style>`

Puedes interpolar expresiones dentro de un `<style>`, pero hay que tener en cuenta:

```tsx
render() {
  return html`
    <style>
      :host {
        /* ‚ö†Ô∏è Este enfoque tiene limitaciones y problemas de rendimiento */
        color: ${this.myColor};
      }
    </style>
    <div>Contenido</div>
  `;
}

```

### üö® Problemas:

- En ShadyCSS, las expresiones **no se actualizan por instancia**.
- `<style>` no puede recibirse como valor de una expresi√≥n con ShadyCSS.
- Evaluar expresiones dentro de `<style>` es **muy ineficiente**:
    - Si cambia una sola expresi√≥n, el navegador debe **reparsear todo el bloque de estilos**.

---

## ‚úÖ Mitigando los problemas

Una soluci√≥n es **separar estilos est√°ticos de los din√°micos**:

```tsx
import {LitElement, html, css} from 'lit';

export class MyElement extends LitElement {
  static styles = css`
    /* Estilos est√°ticos */
    div { font-size: 16px; }
  `;

  red = true;

  render() {
    const redStyle = html`
      <style>
        :host { color: red; }
      </style>
    `;
    return html`
      ${this.red ? redStyle : ''}
      <div>Texto condicionalmente rojo</div>
    `;
  }
}

```

De esta manera:

- Los estilos pesados y est√°ticos siguen en `static styles`.
- Los condicionales o din√°micos se aplican solo cuando es necesario.

---

## ‚öñÔ∏è Resumen

- Usa `static styles` siempre que puedas (m√°s r√°pido y seguro).
- `<style>` dentro del template es √∫til **solo en casos puntuales** de estilos din√°micos o condicionales.
- Evita meter expresiones complejas dentro de `<style>`, porque afecta mucho al rendimiento.
- Con ShadyCSS, las expresiones en `<style>` **no funcionan correctamente**.

---

# üìÑ Usar hojas de estilo externas en Lit (‚ö†Ô∏è No recomendado)

Aunque puedes incluir una **hoja de estilos externa** dentro del template con un `<link>`, esta pr√°ctica **no se recomienda**.

üëâ La forma recomendada siempre es usar la propiedad `static styles` en tu clase de componente.

---

## üîó Ejemplo (no recomendado)

```tsx
render() {
  return html`
    <link rel="stylesheet" href="./styles/global.css">
    <div>Contenido del componente</div>
  `;
}

```

---

## ‚ö†Ô∏è Inconvenientes de las hojas externas

1. ‚ùå **ShadyCSS** (polyfill para navegadores antiguos) **no soporta** hojas externas.
2. ‚ùå Puede producirse un **FOUC (Flash of Unstyled Content)** mientras la hoja externa se carga.
3. ‚ùå El `href` de `<link>` se resuelve **en relaci√≥n al documento principal**, no al componente.
    - Esto es aceptable en **apps** con rutas de assets conocidas.
    - üö´ Pero es un problema en **componentes reutilizables**, ya que no puedes garantizar la ruta del CSS.

## ‚úÖ Conclusi√≥n

- Evita `<link>` con CSS externos dentro de tus componentes.
- Prefiere siempre:

```tsx
static styles = css`
  /* estilos aqu√≠ */
`;

```

- Si necesitas **tematizaci√≥n global**, considera usar **propiedades CSS (`-var`)** que los componentes puedan consumir.

---

# üé≠ Clases y estilos din√°micos en Lit

Una forma de hacer los estilos din√°micos es a√±adir **expresiones** en los atributos `class` o `style` dentro de tu template.

Lit proporciona dos **directivas** muy √∫tiles para esto:

- **`classMap`** ‚Üí aplicar clases din√°micamente.
- **`styleMap`** ‚Üí aplicar estilos inline din√°micamente.

---

## üì¶ C√≥mo usarlas

1. Importa las directivas que necesites:

```tsx
import {classMap} from 'lit/directives/class-map.js';
import {styleMap} from 'lit/directives/style-map.js';

```

1. √ösalas en el template de tu componente:

```jsx
// JS
import {LitElement, html, css} from 'lit';
import {classMap} from 'lit/directives/class-map.js';
import {styleMap} from 'lit/directives/style-map.js';

export class MyElement extends LitElement {
  static properties = {
    classes: {},
    styles: {},
  };

  static styles = css`
    .someclass { border: 1px solid red; padding: 4px; }
    .anotherclass { background-color: navy; color: white; }
  `;

  constructor() {
    super();
    this.classes = { someclass: true, anotherclass: false };
    this.styles = { color: 'lightgreen', fontFamily: 'Roboto' };
  }

  render() {
    return html`
      <div class=${classMap(this.classes)} style=${styleMap(this.styles)}>
        Contenido din√°mico
      </div>
    `;
  }
}

customElements.define('my-element', MyElement);

```

```tsx
//TS
import {LitElement, html, css} from 'lit';
import {customElement, property} from 'lit/decorators.js';
import {classMap} from 'lit/directives/class-map.js';
import {styleMap} from 'lit/directives/style-map.js';

@customElement('my-element')
export class MyElement extends LitElement {
  static styles = css`
    .someclass { border: 1px solid red; padding: 4px; }
    .anotherclass { background-color: navy; }
  `;
  @property()
  classes = { someclass: true, anotherclass: true };
  @property()
  styles = { color: 'lightgreen', fontFamily: 'Roboto' };
  protected render() {
    return html`
      <div class=${classMap(this.classes)} style=${styleMap(this.styles)}>
        Some content
      </div>
    `;
  }
}
```

![image.png](Styles%202572f387d5c3808d8e4dca520c3af890/image%203.png)

---

## üéØ Ejemplo explicado

- `classMap(this.classes)`
    - Aplica al `div` las clases activas en el objeto `classes`.
    - En este caso, `someclass: true` y `anotherclass: false`.
    - Resultado ‚Üí el div tendr√° **solo** `.someclass`.
- `styleMap(this.styles)`
    - Aplica estilos en l√≠nea a partir del objeto `styles`.
    - Resultado ‚Üí `style="color: lightgreen; font-family: Roboto;"`.

---

## ‚úÖ Ventajas

- M√°s limpio que concatenar strings manualmente.
- F√°cil de leer y mantener.
- Reactivo: cuando cambian las propiedades, Lit vuelve a renderizar con los estilos/clases actualizados.

## ‚ö° Resumen

- Usa **`classMap`** para alternar clases din√°micas sin ensuciar el c√≥digo.
- Usa **`styleMap`** para aplicar estilos en l√≠nea a partir de objetos JS.
- Muy √∫til para estados condicionales (ejemplo: `activo/inactivo`, `visible/oculto`, etc.).

---

# üé® Theming en Lit

Con **herencia de CSS** y **propiedades personalizadas (CSS custom properties)** es muy f√°cil crear **componentes tematizables**.

Esto permite que un mismo componente pueda cambiar de aspecto seg√∫n:

- Su **posici√≥n en el √°rbol** (herencia).
- Su **instancia espec√≠fica** (configuraci√≥n por propiedades CSS).

---

## üß© Ejemplo b√°sico de un componente tematizable

```tsx
//TS
import {LitElement, html, css} from 'lit';
import {customElement} from 'lit/decorators.js';

@customElement('my-element')
export class MyElement extends LitElement {
  static styles = css`
    :host {
      color: var(--my-element-text-color, black);
      background: var(--my-element-background-color, white);
      font-family: var(--my-element-font-family, Roboto);
      display: block;
      padding: 8px;
      margin: 8px;
    }
  `;
  protected render() {
    return html`<div>Hello World</div>`;
  }
}

```

```jsx
//JS
import {LitElement, html, css} from 'lit';

export class MyElement extends LitElement {
  static styles = css`
    :host {
      color: var(--my-element-text-color, black);
      background: var(--my-element-background-color, white);
      font-family: var(--my-element-font-family, Roboto);
      display: block;
      padding: 8px;
      margin: 8px;
    }
  `;
  render() {
    return html`<div>Hello World</div>`;
  }
}
customElements.define('my-element', MyElement);

```

![image.png](Styles%202572f387d5c3808d8e4dca520c3af890/image%204.png)

üëâ En este ejemplo:

- `-my-element-text-color` controla el color de texto.
- `-my-element-background-color` controla el fondo.
- `-my-element-font-family` define la fuente.
- Cada propiedad tiene un **valor por defecto** (fallback).

---

## üå≥ CSS Inheritance (herencia de CSS)

La **herencia de CSS** permite que los estilos definidos en un ancestro se propaguen a sus descendientes.

‚ö†Ô∏è No todas las propiedades heredan, pero s√≠ lo hacen:

- `color`
- `font-family` y otras propiedades `font-*`
- Todas las propiedades personalizadas `-*`

Ejemplo:

```html
<style>
  html {
    color: green;
  }
</style>

<my-element></my-element>

```

Resultado: el texto dentro de `my-element` ser√° verde gracias a la herencia.

---

## üéõÔ∏è CSS Custom Properties (variables CSS)

Todas las propiedades personalizadas (`--mi-propiedad`) **heredan autom√°ticamente**.

Esto permite **configurar un componente desde fuera**.

Ejemplo con fondo din√°mico:

```tsx
class MyElement extends LitElement {
  static styles = css`
    :host {
      background-color: var(--my-background, yellow);
    }
  `;
  render() {
    return html`<p>Hello world</p>`;
  }
}

```

Aplicando estilos desde fuera:

```html
<style>
  my-element {
    --my-background: rgb(67, 156, 144);
  }
</style>

<my-element></my-element>

```

---

## üéØ Tematizaci√≥n por instancia

Cada instancia puede tener su propia configuraci√≥n:

```html
<style>
  my-element {
    --my-background: rgb(67, 156, 144); /* tema general */
  }
  my-element.stuff {
    --my-background: #111111; /* tema solo para instancias con .stuff */
  }
</style>

<my-element></my-element>
<my-element class="stuff"></my-element>

```

üëâ As√≠ un mismo componente puede tener **temas distintos** seg√∫n su clase, estado o contexto.

---

## ‚úÖ Resumen

- Usa **herencia CSS** (`color`, `font-family`, etc.) para estilos globales.
- Usa **propiedades personalizadas (`-*`)** para permitir personalizaci√≥n desde fuera.
- Da siempre **valores por defecto** en `var(--propiedad, fallback)`.
- La tematizaci√≥n se puede aplicar **por √°rbol** o **por instancia espec√≠fica**.

---

## üñåÔ∏è¬†Proyecto con ejemplo de cambio de estilos por tema de un button.

[Cambiar theme con Lit.zip](Styles%202572f387d5c3808d8e4dca520c3af890/Cambiar_theme_con_Lit.zip)

![image.png](Styles%202572f387d5c3808d8e4dca520c3af890/image%205.png)

![image.png](Styles%202572f387d5c3808d8e4dca520c3af890/image%206.png)